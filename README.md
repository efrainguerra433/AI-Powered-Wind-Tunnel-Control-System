# Pneumatic Levitation Wind Tunnel with Vision-Based Control

## Overview

This project presents a **pneumatic levitation wind tunnel** controlled in real time using **computer vision and embedded control**. A lightweight ball is levitated inside a **1.04 m acrylic tube**, and its vertical position is regulated by adjusting the airflow generated by a DC motor with a propeller.

The system runs entirely on a **MaixCam (RISC-V SoC with NPU acceleration)** and integrates:

* Embedded AI for perception (YOLOv5)
* Vision-based distance estimation
* System identification
* Closed-loop PID control

This project is intended as an **experimental and educational platform**, as well as a **professional portfolio project** oriented to embedded systems, control, and edge AI applications.

---

## System Architecture

### Hardware

* **Controller:** MaixCam (RISC-V + NPU)
* **Sensor:** Integrated camera (vision-based feedback)
* **Actuator:** DC motor with propeller
* **Power Stage:** IRF540N MOSFET
* **Control Signal:** PWM (Pin A19)
* **Mechanical Structure:** 1.04 m acrylic tube

### Software

* **Language:** MicroPython
* **Framework:** MaixPy v3
* **AI Model:** YOLOv5 (`.mud` format)
* **Architecture:** Modular

  * `main.py` – System orchestration and loop
  * `perception.py` – Vision inference and distance estimation
  * `controller.py` – PID control logic

---

## Perception: Vision-Based Distance Estimation

The system uses a **YOLOv5 object detection model** to detect the ball in each camera frame. The vertical position is estimated using a **pinhole camera model**, based on the width of the detected bounding box.

The distance is computed as:

[ d = \frac{W_{real} \cdot f}{W_{pixel}} ]

Where:

* ( W_{real} = 5.5,cm ) is the real diameter of the ball
* ( f = 365.45,px ) is the calibrated focal length
* ( W_{pixel} ) is the detected bounding box width in pixels

This approach allows **non-contact sensing** without additional hardware sensors.

---

## Control Strategy

### PID Control

A classical **PID controller** is used to regulate the ball position by adjusting the airflow through PWM control of the motor.

PID gains:

* **Kp = 500**
* **Ki = 20**
* **Kd = 5**

The controller runs in discrete time and outputs a PWM duty cycle applied to the motor driver stage.

### System Identification

To design and validate the controller:

* The system was linearized around a **34% duty cycle operating point**
* **PRBS (Pseudo-Random Binary Signals)** were injected
* A mathematical model was obtained using **MATLAB System Identification Toolbox**

This enabled model-based tuning and stability analysis.

---

## Main Control Loop

At each iteration:

1. Capture image frame
2. Run YOLOv5 inference on NPU
3. Extract bounding box and estimate distance
4. Compute control error (reference – measured position)
5. Apply PID control
6. Update PWM duty cycle

The loop is optimized to meet **real-time constraints** on embedded hardware.

---

## Project Structure

```text
├── main.py          # Main application loop
├── perception.py    # Vision and distance estimation
├── controller.py    # PID controller implementation
├── model/
│   └── yolov5.mud   # Trained YOLOv5 model
├── docs/            # Documentation and diagrams
└── README.md
```

---

## Results

* Stable levitation around reference height
* Vision-based feedback without physical sensors
* Real-time performance on embedded AI hardware

This platform demonstrates the feasibility of **closed-loop control using edge AI**.


